<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>手描きアニメーションGIFジェネレータ</title>
  <style>
    canvas { border: 1px solid #000; }
    .toolbar { margin-top: 10px; display: flex; flex-wrap: wrap; gap: 10px; align-items: center;}
    #previewPanel { margin-top: 15px; display: flex; flex-wrap: wrap; gap: 5px; }
    #previewPanel canvas { border: 1px solid gray; cursor: pointer; }
    #outputGif { margin-top: 20px; max-width: 100%; border: 1px solid #ddd; }
  </style>
</head>
<body>
  <h1>手描きアニメーション → GIF生成</h1>
  <canvas id="drawCanvas" width="400" height="300"></canvas>
  <div class="toolbar">
    <button onclick="addFrame()">フレーム追加</button>
    <button onclick="prevFrame()">← 前</button>
    <button onclick="nextFrame()">次 →</button>
    <button onclick="play()">▶ 再生</button>
    <button onclick="toggleEraser()">🧽 消しゴム: <span id="eraserStatus">OFF</span></button>
    <label>太さ: <input type="range" id="brushSize" min="1" max="30" value="2" oninput="changeBrushSize(this.value)"><span id="brushSizeValue">2</span>px</label>
    <button onclick="generateGIF()">GIF生成</button>
    <span>フレーム: <span id="frameIndex">1</span></span>
  </div>
  <div id="previewPanel"></div>
  <img id="outputGif" src="" alt="生成されたGIF">

  <!-- jsgif ライブラリ -->
  <script src="b64.js"></script>
  <script src="LZWEncoder.js"></script>
  <script src="NeuQuant.js"></script>
  <script src="GIFEncoder.js"></script>

  <script>
    const drawCanvas = document.getElementById("drawCanvas");
    const ctx = drawCanvas.getContext("2d", { willReadFrequently: true });

    let isDrawing = false;
    let brushSize = 2;
    let eraserMode = false;

    let frames = [];
    let currentFrameIndex = 0;

    drawCanvas.addEventListener("mousedown", startDrawing);
    drawCanvas.addEventListener("mousemove", draw);
    drawCanvas.addEventListener("mouseup", () => isDrawing = false);
    drawCanvas.addEventListener("mouseleave", () => isDrawing = false);

    function startDrawing(e) {
      isDrawing = true;
      ctx.beginPath();
      ctx.moveTo(e.offsetX, e.offsetY);
    }

    function draw(e) {
      if (!isDrawing) return;
      ctx.lineWidth = brushSize;
      ctx.lineCap = "round";
      ctx.strokeStyle = eraserMode ? "#ffffff" : "#000000";
      ctx.lineTo(e.offsetX, e.offsetY);
      ctx.stroke();
    }

    function changeBrushSize(value) {
      brushSize = parseInt(value);
      document.getElementById("brushSizeValue").textContent = value;
    }

    function toggleEraser() {
      eraserMode = !eraserMode;
      document.getElementById("eraserStatus").textContent = eraserMode ? "ON" : "OFF";
    }

    function addFrame() {
      // 一時キャンバスで確実に状態を保存
      const tempCanvas = document.createElement("canvas");
      tempCanvas.width = drawCanvas.width;
      tempCanvas.height = drawCanvas.height;
      const tempCtx = tempCanvas.getContext("2d", { willReadFrequently: true });

      tempCtx.drawImage(drawCanvas, 0, 0);
      const imageData = tempCtx.getImageData(0, 0, drawCanvas.width, drawCanvas.height);
      frames.push(imageData);
      currentFrameIndex = frames.length - 1;
      updateFrameDisplay();
      addPreview(imageData, currentFrameIndex);
    }

    function prevFrame() {
      if (currentFrameIndex > 0) {
        currentFrameIndex--;
        loadFrame(currentFrameIndex);
      }
    }

    function nextFrame() {
      if (currentFrameIndex < frames.length - 1) {
        currentFrameIndex++;
        loadFrame(currentFrameIndex);
      }
    }

    function loadFrame(index) {
      if (frames[index]) {
        ctx.putImageData(frames[index], 0, 0);
        updateFrameDisplay();
      }
    }

    function updateFrameDisplay() {
      document.getElementById("frameIndex").textContent = currentFrameIndex + 1;
    }

    function addPreview(imageData, index) {
      const previewCanvas = document.createElement("canvas");
      previewCanvas.width = 80;
      previewCanvas.height = 60;
      const previewCtx = previewCanvas.getContext("2d");
      const tmpCanvas = document.createElement("canvas");
      tmpCanvas.width = drawCanvas.width;
      tmpCanvas.height = drawCanvas.height;
      const tmpCtx = tmpCanvas.getContext("2d");
      tmpCtx.putImageData(imageData, 0, 0);
      previewCtx.drawImage(tmpCanvas, 0, 0, 80, 60);
      previewCanvas.onclick = () => {
        currentFrameIndex = index;
        loadFrame(index);
      };
      document.getElementById("previewPanel").appendChild(previewCanvas);
    }

    function play() {
      let i = 0;
      const interval = setInterval(() => {
        if (i >= frames.length) {
          clearInterval(interval);
          return;
        }
        ctx.putImageData(frames[i], 0, 0);
        updateFrameDisplay();
        i++;
      }, 200);
    }

    function generateGIF() {
      if (frames.length === 0) {
        alert("フレームがありません。");
        return;
      }

      const encoder = new GIFEncoder();
      encoder.setRepeat(0);
      encoder.setDelay(200);
      encoder.start();

      const gifCanvas = document.createElement("canvas");
      gifCanvas.width = drawCanvas.width;
      gifCanvas.height = drawCanvas.height;
      const gifCtx = gifCanvas.getContext("2d", { willReadFrequently: true });

      for (let frame of frames) {
        gifCtx.putImageData(frame, 0, 0);         // ピクセル配置
        encoder.addFrame(gifCtx);                // 描画済みCanvasを追加
      }

      encoder.finish();
      const binaryGif = encoder.stream().getData();
      const dataUrl = "data:image/gif;base64," + encode64(binaryGif);
      document.getElementById("outputGif").src = dataUrl;
    }
  </script>
</body>
</html>

